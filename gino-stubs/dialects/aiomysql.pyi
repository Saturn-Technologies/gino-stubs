from typing import (
    Any,
    ClassVar,
    Generator,
    List,
    NoReturn,
    Optional,
    Type,
    TypeVar,
    overload,
)

from sqlalchemy.dialects.mysql import ENUM
from sqlalchemy.dialects.mysql.base import (
    MySQLCompiler,
    MySQLDialect,
    MySQLExecutionContext,
)
from sqlalchemy.sql import sqltypes

from ..bakery import BakedQuery, Bakery
from ..engine import _DBAPIConnection
from . import base

_T = TypeVar('_T')
_BP = TypeVar('_BP', bound=base.Pool[Any, Any])

JSON_COLTYPE: int

class AiomysqlDBAPI(base.BaseDBAPI):
    paramstyle: ClassVar[str]

class AiomysqlExecutionContext(base.ExecutionContextOverride, MySQLExecutionContext):
    def get_lastrowid(self) -> Any: ...
    def get_affected_rows(self) -> int: ...

class AiomysqlIterator(base.Cursor[_T]):
    _AI = TypeVar('_AI', bound='AiomysqlIterator[Any]')
    def __init__(self, context: AiomysqlExecutionContext, cursor: Any) -> None: ...
    def __await__(self) -> Generator[Any, None, _AI]: ...
    def __aiter__(self: _AI) -> _AI: ...
    async def __anext__(self) -> _T: ...
    async def many(self, n: int, *, timeout: float = ...) -> List[_T]: ...
    async def next(self, *, timeout: float = ...) -> Optional[_T]: ...
    async def forward(self, n: int, *, timeout: float = ...) -> None: ...

class DBAPICursor(base.DBAPICursor[AiomysqlExecutionContext]):
    last_row_id: Any
    affected_rows: int
    def __init__(self: _T, dbapi_conn: _DBAPIConnection[_T]) -> None: ...
    async def prepare(
        self, context: AiomysqlExecutionContext, clause: Optional[Any] = ...
    ) -> NoReturn: ...
    async def async_execute(
        self, query: Any, timeout: Any, args: Any, limit: int = ..., many: bool = ...
    ) -> Any: ...
    async def execute_baked(
        self, baked_query: BakedQuery[Any], timeout: Any, args: Any, one: bool
    ) -> Any: ...
    @property
    def description(self) -> Any: ...
    def get_statusmsg(self) -> Any: ...
    def iterate(self, context: AiomysqlExecutionContext) -> AiomysqlIterator[Any]: ...

class Pool(base.Pool[Any, Any]):
    _P = TypeVar('_P', bound='Pool')
    def __init__(
        self,
        url: Any,
        loop: Any,
        init: Optional[Any] = ...,
        bakery: Optional[Any] = ...,
        prebake: bool = ...,
        **kwargs: Any,
    ) -> None: ...
    def __await__(self) -> Generator[Any, None, _P]: ...
    @property
    def raw_pool(self) -> Any: ...
    async def acquire(self, *, timeout: Optional[Any] = ...) -> Any: ...
    async def release(self, conn: Any) -> None: ...
    async def close(self) -> None: ...
    def repr(self, color: bool) -> str: ...

class Transaction(base.Transaction):
    def __init__(self, conn: Any, set_isolation: Optional[Any] = ...) -> None: ...
    @property
    def raw_transaction(self) -> Any: ...
    async def begin(self) -> None: ...
    async def commit(self) -> None: ...
    async def rollback(self) -> None: ...

class AsyncEnum(ENUM):
    async def create_async(
        self, bind: Optional[Any] = ..., checkfirst: bool = ...
    ) -> None: ...
    async def drop_async(
        self, bind: Optional[Any] = ..., checkfirst: bool = ...
    ) -> None: ...

class GinoNullType(sqltypes.NullType):
    def result_processor(self, dialect: Any, coltype: Any) -> Any: ...

class AiomysqlDialect(MySQLDialect, base.AsyncDialectMixin[AiomysqlExecutionContext]):
    driver: ClassVar[str]
    supports_native_decimal: bool
    dbapi_class: ClassVar[Type[AiomysqlDBAPI]]
    statement_compiler: Type[MySQLCompiler]
    execution_ctx_cls: ClassVar[Type[AiomysqlExecutionContext]]
    cursor_cls: ClassVar[Type[DBAPICursor]]
    init_kwargs: Any
    colspecs: Any
    postfetch_lastrowid: bool
    support_returning: ClassVar[bool]
    support_prepare: ClassVar[bool]
    server_version_info: Any
    def __init__(
        self, *args: Any, bakery: Optional[Bakery] = ..., **kwargs: Any
    ) -> None: ...
    @overload
    async def init_pool(self, url: Any, loop: Any, pool_class: None = ...) -> Pool: ...
    @overload
    async def init_pool(self, url: Any, loop: Any, pool_class: Type[_BP]) -> _BP: ...
    def transaction(self, raw_conn: Any, args: Any, kwargs: Any) -> Transaction: ...
    def on_connect(self) -> Optional[Any]: ...
    async def set_isolation_level(self, connection: Any, level: Any) -> None: ...
    async def get_isolation_level(self, connection: Any) -> str: ...
    async def has_table(
        self, connection: Any, table_name: Any, schema: Optional[Any] = ...
    ) -> bool: ...
