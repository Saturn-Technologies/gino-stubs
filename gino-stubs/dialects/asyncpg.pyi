from typing import Any, Generator, List, Optional, Type, TypeVar, overload

import asyncpg
import asyncpg.pool
from sqlalchemy.dialects.postgresql import ARRAY as ARRAY
from sqlalchemy.dialects.postgresql import JSON as JSON
from sqlalchemy.dialects.postgresql import JSONB as JSONB
from sqlalchemy.dialects.postgresql.base import (
    ENUM,
    PGCompiler,
    PGDialect,
    PGExecutionContext,
)
from sqlalchemy.sql import sqltypes

from . import base

_T = TypeVar('_T')
_P = TypeVar('_P', bound=base.Pool[Any, Any])

JSON_COLTYPE: int
JSONB_COLTYPE: int

class AsyncpgDBAPI(base.BaseDBAPI):
    Error: Any = ...

class AsyncpgCompiler(PGCompiler):
    bindtemplate: str

class AsyncpgExecutionContext(base.ExecutionContextOverride, PGExecutionContext): ...

class AsyncpgIterator:
    def __init__(self, context: Any, iterator: Any) -> None: ...
    async def __anext__(self) -> Any: ...

class AsyncpgCursor(base.Cursor[_T]):
    def __init__(self, context: Any, cursor: Any) -> None: ...
    async def many(self, n: int, *, timeout: float = ...) -> List[_T]: ...
    async def next(self, *, timeout: float = ...) -> Optional[_T]: ...
    async def forward(self, n: int, *, timeout: float = ...) -> None: ...

class PreparedStatement(base.PreparedStatement[_T]):
    def __init__(self, prepared: Any, clause: Optional[Any] = ...) -> None: ...

class DBAPICursor(base.DBAPICursor):
    def __init__(self, dbapi_conn: Any) -> None: ...
    async def prepare(
        self, context: Any, clause: Optional[Any] = ...
    ) -> PreparedStatement[Any]: ...
    async def async_execute(
        self, query: Any, timeout: Any, args: Any, limit: int = ..., many: bool = ...
    ) -> Any: ...
    @property
    def description(self) -> Any: ...
    def get_statusmsg(self) -> Any: ...

class Pool(base.Pool[asyncpg.pool.Pool[Any], asyncpg.pool.PoolConnectionProxy[Any]]):
    def __init__(self, url: Any, loop: Any, **kwargs: Any) -> None: ...
    def __await__(self) -> Generator[Any, None, Pool]: ...
    @property
    def raw_pool(self) -> asyncpg.pool.Pool[Any]: ...
    async def acquire(
        self, *, timeout: Optional[Any] = ...
    ) -> asyncpg.pool.PoolConnectionProxy[Any]: ...
    async def release(self, conn: Any) -> None: ...
    async def close(self) -> None: ...
    def repr(self, color: bool) -> str: ...

class Transaction(base.Transaction):
    def __init__(self, tx: Any) -> None: ...
    @property
    def raw_transaction(self) -> Any: ...
    async def begin(self) -> None: ...
    async def commit(self) -> None: ...
    async def rollback(self) -> None: ...

class AsyncEnum(ENUM):
    async def create_async(
        self, bind: Optional[Any] = ..., checkfirst: bool = ...
    ) -> None: ...
    async def drop_async(
        self, bind: Optional[Any] = ..., checkfirst: bool = ...
    ) -> None: ...

class GinoNullType(sqltypes.NullType):
    def result_processor(self, dialect: Any, coltype: Any) -> Any: ...

class AsyncpgDialect(PGDialect, base.AsyncDialectMixin):
    driver: str = ...
    supports_native_decimal: bool = ...
    dbapi_class: Any = ...
    statement_compiler: Any = ...
    execution_ctx_cls: Any = ...
    cursor_cls: Any = ...
    dbapi_type_map: Any = ...
    init_kwargs: Any = ...
    colspecs: Any = ...
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    @overload
    async def init_pool(self, url: Any, loop: Any) -> Pool: ...
    @overload
    async def init_pool(self, url: Any, loop: Any, pool_class: Type[_P]) -> _P: ...
    def transaction(self, raw_conn: Any, args: Any, kwargs: Any) -> Transaction: ...
    def on_connect(self) -> Optional[Any]: ...
    async def set_isolation_level(  # type: ignore
        self, connection: Any, level: Any
    ) -> None: ...
    async def get_isolation_level(self, connection: Any) -> str: ...
    async def has_schema(self, connection: Any, schema: Any) -> bool: ...
    async def has_table(
        self, connection: Any, table_name: Any, schema: Optional[Any] = ...
    ) -> bool: ...
    async def has_sequence(
        self, connection: Any, sequence_name: Any, schema: Optional[Any] = ...
    ) -> bool: ...
    async def has_type(
        self, connection: Any, type_name: Any, schema: Optional[Any] = ...
    ) -> bool: ...
