from typing import (
    Any,
    ClassVar,
    Generator,
    List,
    Optional,
    Tuple,
    Type,
    TypeVar,
    overload,
)

import asyncpg
import asyncpg.pool
from sqlalchemy.dialects.postgresql import ARRAY as ARRAY
from sqlalchemy.dialects.postgresql import JSON as JSON
from sqlalchemy.dialects.postgresql import JSONB as JSONB
from sqlalchemy.dialects.postgresql import json as json
from sqlalchemy.dialects.postgresql.base import (
    ENUM,
    PGCompiler,
    PGDialect,
    PGExecutionContext,
)
from sqlalchemy.sql import sqltypes

from ..bakery import BakedQuery, Bakery
from ..engine import _DBAPIConnection
from . import base

_T = TypeVar('_T')
_BP = TypeVar('_BP', bound=base.Pool[Any, Any])

JSON_COLTYPE: int
JSONB_COLTYPE: int

class AsyncpgDBAPI(base.BaseDBAPI):
    Error: ClassVar[Tuple[Type[Exception], ...]]

class AsyncpgCompiler(PGCompiler):
    bindtemplate: str

class AsyncpgExecutionContext(base.ExecutionContextOverride, PGExecutionContext): ...

class AsyncpgIterator:
    def __init__(self, context: AsyncpgExecutionContext, iterator: Any) -> None: ...
    async def __anext__(self) -> Any: ...

class AsyncpgCursor(base.Cursor[_T]):
    def __init__(self, context: AsyncpgExecutionContext, cursor: Any) -> None: ...
    async def many(self, n: int, *, timeout: float = ...) -> List[_T]: ...
    async def next(self, *, timeout: float = ...) -> Optional[_T]: ...
    async def forward(self, n: int, *, timeout: float = ...) -> None: ...

class PreparedStatement(base.PreparedStatement[_T]):
    def __init__(self, prepared: Any, clause: Optional[Any] = ...) -> None: ...

class DBAPICursor(base.DBAPICursor[AsyncpgExecutionContext]):
    def __init__(self: _T, dbapi_conn: _DBAPIConnection[_T]) -> None: ...
    async def prepare(
        self, context: AsyncpgExecutionContext, clause: Optional[Any] = ...
    ) -> PreparedStatement[Any]: ...
    async def async_execute(
        self, query: Any, timeout: Any, args: Any, limit: int = ..., many: bool = ...
    ) -> Any: ...
    async def execute_baked(
        self, baked_query: BakedQuery[Any], timeout: Any, args: Any, one: bool
    ) -> Any: ...
    @property
    def description(self) -> Any: ...
    def get_statusmsg(self) -> Any: ...

class Pool(base.Pool[asyncpg.pool.Pool, asyncpg.pool.PoolConnectionProxy]):
    _P = TypeVar('_P', bound='Pool')
    def __init__(
        self,
        url: Any,
        loop: Any,
        bakery: Optional[Bakery] = ...,
        prebake: bool = ...,
        **kwargs: Any,
    ) -> None: ...
    def __await__(self: _P) -> Generator[Any, None, _P]: ...
    @property
    def raw_pool(self) -> asyncpg.pool.Pool: ...
    async def acquire(
        self, *, timeout: Optional[Any] = ...
    ) -> asyncpg.pool.PoolConnectionProxy: ...
    async def release(self, conn: Any) -> None: ...
    async def close(self) -> None: ...
    def repr(self, color: bool) -> str: ...

class NullPool(base.Pool[NullPool, asyncpg.Connection]):
    def __init__(
        self,
        url: Any,
        loop: Any,
        **kwargs: Any,
    ) -> None: ...
    def __await__(self) -> Generator[Any, None, NullPool]: ...
    @property
    def raw_pool(self) -> NullPool: ...
    async def acquire(self, *, timeout: Optional[Any] = ...) -> asyncpg.Connection: ...
    async def release(self, conn: Any) -> None: ...
    async def close(self) -> None: ...
    def repr(self, color: bool) -> str: ...

class Transaction(base.Transaction):
    def __init__(self, tx: Any) -> None: ...
    @property
    def raw_transaction(self) -> Any: ...
    async def begin(self) -> None: ...
    async def commit(self) -> None: ...
    async def rollback(self) -> None: ...

class AsyncEnum(ENUM):
    async def create_async(
        self, bind: Optional[Any] = ..., checkfirst: bool = ...
    ) -> None: ...
    async def drop_async(
        self, bind: Optional[Any] = ..., checkfirst: bool = ...
    ) -> None: ...

class GinoNullType(sqltypes.NullType):
    def result_processor(self, dialect: Any, coltype: Any) -> Any: ...

class AsyncpgJSONPathType(json.JSONPathType):  # type: ignore
    def bind_processor(self, dialect: Any) -> Any: ...

class AsyncpgDialect(PGDialect, base.AsyncDialectMixin[AsyncpgExecutionContext]):
    driver: ClassVar[str]
    supports_native_decimal: bool
    dbapi_class: ClassVar[Type[AsyncpgDBAPI]]
    statement_compiler: Type[AsyncpgCompiler]
    execution_ctx_cls: Type[AsyncpgExecutionContext]
    cursor_cls: ClassVar[Type[DBAPICursor]]
    init_kwargs: Any
    colspecs: Any
    def __init__(
        self, *args: Any, bakery: Optional[Bakery] = ..., **kwargs: Any
    ) -> None: ...
    @overload
    async def init_pool(self, url: Any, loop: Any, pool_class: None = ...) -> Pool: ...
    @overload
    async def init_pool(self, url: Any, loop: Any, pool_class: Type[_BP]) -> _BP: ...
    def transaction(self, raw_conn: Any, args: Any, kwargs: Any) -> Transaction: ...
    def on_connect(self) -> Optional[Any]: ...
    async def set_isolation_level(  # type: ignore
        self, connection: Any, level: Any
    ) -> None: ...
    async def get_isolation_level(self, connection: Any) -> str: ...
    async def has_schema(self, connection: Any, schema: Any) -> bool: ...
    async def has_table(
        self, connection: Any, table_name: Any, schema: Optional[Any] = ...
    ) -> bool: ...
    async def has_sequence(
        self, connection: Any, sequence_name: Any, schema: Optional[Any] = ...
    ) -> bool: ...
    async def has_type(
        self, connection: Any, type_name: Any, schema: Optional[Any] = ...
    ) -> bool: ...
