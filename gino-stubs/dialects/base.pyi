from typing import (
    Any,
    AsyncIterator,
    ClassVar,
    Generator,
    Generic,
    List,
    Optional,
    Tuple,
    Type,
    TypeVar,
    Union,
    overload,
)

from ..bakery import BakedQuery
from ..engine import _DBAPIConnection, _SAConnection, _SAEngine
from ..loader import Loader

DEFAULT: Any

_T = TypeVar('_T')
_U = TypeVar('_U')
_P = TypeVar('_P', bound=Pool[Any, Any])
_E = TypeVar('_E', bound=ExecutionContextOverride)

class BaseDBAPI:
    paramstyle: ClassVar[str]
    Error: ClassVar[Union[Type[Exception], Tuple[Type[Exception], ...]]]
    @staticmethod
    def Binary(x: Any) -> Any: ...

class DBAPICursor(Generic[_E]):
    def execute(self, statement: Any, parameters: Any) -> None: ...
    def executemany(self, statement: Any, parameters: Any) -> None: ...
    @property
    def description(self) -> None: ...
    async def prepare(
        self, context: _E, clause: Optional[Any] = ...
    ) -> PreparedStatement[Any]: ...
    async def async_execute(
        self, query: Any, timeout: Any, args: Any, limit: int = ..., many: bool = ...
    ) -> None: ...
    async def execute_baked(
        self, baked_query: Any, timeout: Any, args: Any, one: Any
    ) -> Any: ...
    def get_statusmsg(self) -> None: ...

class Pool(Generic[_T, _U]):
    @property
    def raw_pool(self) -> _T: ...
    async def acquire(self, *, timeout: Optional[Any] = ...) -> _U: ...
    async def release(self, conn: Any) -> None: ...
    async def close(self) -> None: ...

class Transaction:
    @property
    def raw_transaction(self) -> Any: ...
    async def begin(self) -> None: ...
    async def commit(self) -> None: ...
    async def rollback(self) -> None: ...

class PreparedStatement(Generic[_T]):
    context: Optional[Any]
    clause: Optional[Any]
    def __init__(self, clause: Optional[Any] = ...) -> None: ...
    def iterate(self, *params: Any, **kwargs: Any) -> _PreparedIterableCursor[_T]: ...
    async def all(self, *multiparams: Any, **params: Any) -> List[_T]: ...
    async def first(self, *multiparams: Any, **params: Any) -> _T: ...
    async def scalar(self, *multiparams: Any, **params: Any) -> Any: ...
    async def status(self, *multiparams: Any, **params: Any) -> Any: ...

class _PreparedIterableCursor(Generic[_T]):
    def __init__(self, prepared: Any, params: Any, kwargs: Any) -> None: ...
    def __aiter__(self) -> AsyncIterator[_T]: ...
    def __await__(self) -> Generator[Any, None, Cursor[_T]]: ...

class _IterableCursor(Generic[_T]):
    def __init__(self, context: _E) -> None: ...
    def __aiter__(self) -> _LazyIterator[_T]: ...
    def __await__(self) -> Generator[Any, None, Cursor[_T]]: ...

class _LazyIterator(Generic[_T]):
    def __init__(self, init: Any) -> None: ...
    async def __anext__(self) -> _T: ...

class _ResultProxy(Generic[_T]):
    def __init__(self, context: _E) -> None: ...
    @property
    def context(self) -> _E: ...
    async def execute(
        self,
        one: bool = ...,
        return_model: bool = ...,
        status: bool = ...,
        return_context: bool = ...,
    ) -> Any: ...
    def iterate(self) -> _IterableCursor[_T]: ...
    async def prepare(self, clause: Any) -> PreparedStatement[_T]: ...

class Cursor(Generic[_T]):
    async def many(self, n: int, *, timeout: float = ...) -> List[_T]: ...
    async def next(self, *, timeout: float = ...) -> Optional[_T]: ...
    async def forward(self, n: int, *, timeout: float = ...) -> None: ...

class ExecutionContextOverride:
    baked_query: Optional[BakedQuery[Any]]
    @property
    def return_model(self) -> bool: ...
    @property
    def model(self) -> Optional[Type[Any]]: ...
    @property
    def timeout(self) -> Optional[float]: ...
    @property
    def loader(self) -> Optional[Any]: ...
    def process_rows(self, rows: Any, return_model: bool = ...) -> Any: ...
    def get_result_proxy(self) -> _ResultProxy[Any]: ...
    def get_lastrowid(self) -> Any: ...
    def get_affected_rows(self) -> int: ...

class AsyncDialectMixin(Generic[_E]):
    cursor_cls: ClassVar[Type[DBAPICursor[_E]]]
    dbapi_class: ClassVar[Type[BaseDBAPI]]
    support_returning: ClassVar[bool]
    support_prepare: ClassVar[bool]
    @classmethod
    def dbapi(cls) -> Type[BaseDBAPI]: ...
    def compile(self, elem: Any, *multiparams: Any, **params: Any) -> Any: ...
    @overload
    async def init_pool(
        self, url: Any, loop: Any, pool_class: None = ...
    ) -> Pool[Any, Any]: ...
    @overload
    async def init_pool(self, url: Any, loop: Any, pool_class: Type[_P]) -> _P: ...
    def transaction(self, raw_conn: Any, args: Any, kwargs: Any) -> Transaction: ...
