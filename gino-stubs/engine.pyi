import asyncio
from typing import (
    Any,
    Generator,
    Generic,
    Iterable,
    Optional,
    Tuple,
    Type,
    TypeVar,
    Union,
)

from sqlalchemy.engine import Connection, Dialect, Engine
from sqlalchemy.engine.interfaces import Compiled
from sqlalchemy.schema import DDLElement, DefaultGenerator
from sqlalchemy.sql.expression import ClauseElement
from sqlalchemy.sql.functions import FunctionElement

from .dialects.base import Pool, PreparedStatement, _IterableCursor
from .transaction import GinoTransaction

StatementType = Union[str, ClauseElement, FunctionElement, DDLElement, DefaultGenerator]
StatementAndCompiledType = Union[StatementType, Compiled]

_T = TypeVar('_T')

class _BaseDBAPIConnection(Generic[_T]):
    gino_conn: Any = ...
    def __init__(self, cursor_cls: Type[_T]) -> None: ...
    def commit(self) -> None: ...
    def cursor(self) -> _T: ...
    @property
    def raw_connection(self) -> Any: ...
    async def acquire(self, *, timeout: Optional[float] = ...) -> Any: ...
    async def release(self, permanent: bool) -> None: ...

class _DBAPIConnection(_BaseDBAPIConnection[_T]):
    def __init__(self, cursor_cls: Type[_T], pool: Optional[Any] = ...) -> None: ...
    @property
    def raw_connection(self) -> Any: ...

class _ReusingDBAPIConnection(_BaseDBAPIConnection[_T]):
    def __init__(self, cursor_cls: Type[_T], root: Any) -> None: ...
    @property
    def raw_connection(self) -> Any: ...

class _bypass_no_param:
    def keys(self) -> Iterable[Any]: ...

class _SAConnection(Connection): ...

class _SAEngine(Engine):
    def __init__(self, dialect: Dialect, **kwargs: Any) -> None: ...

class _TransactionContext:
    async def __aenter__(self) -> GinoTransaction: ...
    async def __aexit__(self, *exc_info: Any) -> Optional[bool]: ...

class GinoConnection:
    schema_for_object: Any = ...
    def __init__(
        self, dialect: Dialect, sa_conn: Any, stack: Optional[Any] = ...
    ) -> None: ...
    @property
    def raw_connection(self) -> Any: ...
    async def get_raw_connection(self, *, timeout: Optional[float] = ...) -> Any: ...
    async def release(self, *, permanent: bool = ...) -> None: ...
    @property
    def dialect(self) -> Dialect: ...
    async def all(self, clause: Any, *multiparams: Any, **params: Any) -> Any: ...
    async def first(self, clause: Any, *multiparams: Any, **params: Any) -> Any: ...
    async def one_or_none(
        self, clause: Any, *multiparams: Any, **params: Any
    ) -> Any: ...
    async def one(self, clause: Any, *multiparams: Any, **params: Any) -> Any: ...
    async def scalar(self, clause: Any, *multiparams: Any, **params: Any) -> Any: ...
    async def status(self, clause: Any, *multiparams: Any, **params: Any) -> Any: ...
    def transaction(self, *args: Any, **kwargs: Any) -> GinoTransaction: ...
    def iterate(
        self, clause: Any, *multiparams: Any, **params: Any
    ) -> _IterableCursor[Any]: ...
    def execution_options(self: _T, **opt: Any) -> _T: ...
    async def prepare(self, clause: Any) -> PreparedStatement[Any]: ...

class _AcquireContext:
    def __init__(self, acquire: Any) -> None: ...
    async def __aenter__(self) -> GinoConnection: ...
    async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None: ...
    def __await__(self) -> Generator[Any, None, GinoConnection]: ...

class GinoEngine:
    connection_cls: Type[GinoConnection]
    def __init__(
        self,
        dialect: Dialect,
        pool: Pool[Any, Any],
        loop: asyncio.AbstractEventLoop,
        logging_name: Optional[Any] = ...,
        echo: Optional[Any] = ...,
        execution_options: Optional[Any] = ...,
    ) -> None: ...
    @property
    def dialect(self) -> Dialect: ...
    @property
    def raw_pool(self) -> Any: ...
    def acquire(
        self,
        *,
        timeout: Optional[Any] = ...,
        reuse: bool = ...,
        lazy: bool = ...,
        reusable: bool = ...,
    ) -> _AcquireContext: ...
    @property
    def current_connection(self) -> Optional[GinoConnection]: ...
    async def close(self) -> None: ...
    async def all(self, clause: Any, *multiparams: Any, **params: Any) -> Any: ...
    async def first(self, clause: Any, *multiparams: Any, **params: Any) -> Any: ...
    async def one_or_none(
        self, clause: Any, *multiparams: Any, **params: Any
    ) -> Any: ...
    async def one(self, clause: Any, *multiparams: Any, **params: Any) -> Any: ...
    async def scalar(self, clause: Any, *multiparams: Any, **params: Any) -> Any: ...
    async def status(self, clause: Any, *multiparams: Any, **params: Any) -> Any: ...
    def compile(
        self, clause: StatementType, *multiparams: Any, **params: Any
    ) -> Tuple[str, Any]: ...
    def transaction(
        self,
        *args: Any,
        timeout: Optional[Any] = ...,
        reuse: bool = ...,
        reusable: bool = ...,
        **kwargs: Any,
    ) -> _TransactionContext: ...
    def iterate(
        self, clause: Any, *multiparams: Any, **params: Any
    ) -> _IterableCursor[Any]: ...
    def update_execution_options(self, **opt: Any) -> None: ...
